import{_ as a,c as n,o as s,d as e}from"./app.0fdc3d94.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"spring 框架","slug":"spring-框架","link":"#spring-框架","children":[]},{"level":3,"title":"Spring的介绍","slug":"spring的介绍","link":"#spring的介绍","children":[]},{"level":3,"title":"Spring提供的容器又称为IoC容器，什么是IoC？","slug":"spring提供的容器又称为ioc容器-什么是ioc","link":"#spring提供的容器又称为ioc容器-什么是ioc","children":[]},{"level":3,"title":"IOC 反转","slug":"ioc-反转","link":"#ioc-反转","children":[]},{"level":3,"title":"Java  Bean","slug":"java-bean","link":"#java-bean","children":[]},{"level":3,"title":"java 的反射","slug":"java-的反射","link":"#java-的反射","children":[]},{"level":3,"title":"Spring  boot 的版本","slug":"spring-boot-的版本","link":"#spring-boot-的版本","children":[]},{"level":3,"title":"spring boot 中的@","slug":"spring-boot-中的","link":"#spring-boot-中的","children":[]}],"relativePath":"devm/java/spring/index.md"}'),l={name:"devm/java/spring/index.md"},p=e(`<h3 id="spring-框架" tabindex="-1">spring 框架 <a class="header-anchor" href="#spring-框架" aria-hidden="true">#</a></h3><ul><li>Spring是什么</li><li>Spring带来了什么</li><li>Spring有什么好处</li><li>Spring结构图</li><li>Spring应用场景</li></ul><h3 id="spring的介绍" tabindex="-1">Spring的介绍 <a class="header-anchor" href="#spring的介绍" aria-hidden="true">#</a></h3><p><code>Spring是一个开发应用框架，什么样的框架呢，有这么几个标签：轻量级、非侵入式、一站式、模块化，其目的是用于简化企业级应用程序开发。</code></p><p>我们知道应用程序是由一组相互协作的对象组成，而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。当然，我们也可以通过自我能力，利用前人总结出来的设计模式来进行我们的架构设计，比如常见的「工厂模式」、「代理模式」等，总共有23种模式，利用别人总结的轮子来进行我们自己轮子建造，但如何这些轮子建造专门交给一个叫做Spring的人去帮你做，你只需要专心你的业务逻辑，是不是省心很多，同时这个叫Spring干的又专业又稳定，何乐而不为呢。</p><h3 id="spring提供的容器又称为ioc容器-什么是ioc" tabindex="-1">Spring提供的容器又称为IoC容器，什么是IoC？ <a class="header-anchor" href="#spring提供的容器又称为ioc容器-什么是ioc" aria-hidden="true">#</a></h3><p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？ IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如： 在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean</p><h3 id="ioc-反转" tabindex="-1">IOC 反转 <a class="header-anchor" href="#ioc-反转" aria-hidden="true">#</a></h3><p>JavaBean 是 Java 平台中一种特殊的类，它是一种符合 JavaBeans 规范的可重用组件，主要用于在 Java 应用程序中传递数据。JavaBean 是一个无状态的对象，它封装了一个或多个属性，并通过 getter 和 setter 方法来提供对这些属性的访问。JavaBean 还可以实现一些其他的特定接口，如 Serializable 和 Cloneable 接口，以便于将其序列化和复制</p><p>可以将Spring的IOC（控制反转）、AOP（面向切面编程）、声明式事务和MyBatis比喻为一个餐厅的运营模式和工具。</p><ol><li><p>IOC（控制反转）：餐厅的运营模式是由顾客来决定他们想要吃什么，而不是餐厅主动推荐菜品。类比到Spring的IOC，它将对象的创建和依赖关系的管理交给了容器来处理。开发人员只需定义对象和它们之间的依赖关系，而无需手动创建和管理对象。这样可以降低代码的耦合性，提高代码的可维护性和可测试性。</p></li><li><p>AOP（面向切面编程）：在餐厅中，有一些与菜品无关的共同操作，如欢迎顾客、记录订单、清理桌子等。类比到Spring的AOP，它允许开发人员将这些共同操作（称为切面）与业务逻辑（称为切点）分离开来。通过AOP，开发人员可以在不修改业务逻辑的情况下，将共同操作应用到多个地方，提高代码的重用性和可维护性。</p></li><li><p>声明式事务：在餐厅中，有一些需要保证一致性和完整性的操作，如下单、支付等。类比到Spring的声明式事务，它允许开发人员使用注解或XML配置来定义事务的边界和属性。这样，开发人员无需手动编写事务管理的代码，而是将事务的管理交给了Spring框架。这简化了事务管理的过程，提高了代码的可读性和可维护性。</p></li><li><p>MyBatis：在餐厅中，有一些需要从数据库中获取数据的操作，如查询菜单、查看订单等。类比到MyBatis，它是一个持久层框架，用于简化数据库访问的过程。通过MyBatis，开发人员可以使用简洁的SQL语句来操作数据库，而无需手动编写繁琐的JDBC代码。这提高了开发效率和代码的可读性。</p></li></ol><p>这些Spring的特性和工具的作用是为了解决实际的开发问题。它们可以降低代码的耦合性，提高代码的可维护性和可测试性。IOC和AOP使开发人员能够更专注于业务逻辑的实现，而无需过多关注底层的技术细节。声明式事务简化了事务管理的过程，提高了代码的可读性和可维护性。MyBatis简化了数据库访问的过程，提高了开发效率和代码的可读性。</p><p>总结起来，Spring的IOC、AOP、声明式事务和MyBatis可以比喻为餐厅的运营模式和工具。它们的作用是简化开发过程，提高代码的可维护性和可测试性，解决实际的开发问题。</p><h3 id="java-bean" tabindex="-1">Java Bean <a class="header-anchor" href="#java-bean" aria-hidden="true">#</a></h3><p>Java Bean是一个普通的Java类，它具有私有的属性（食材）和公共的getter和setter方法（装饭和取饭的动作）。这些属性和方法可以被其他类访问和操作。</p><p>使用Java Bean的目的是为了封装数据和行为，使其更易于管理和操作。类似于饭盒中的食材，Java Bean中的属性可以存储数据，而getter和setter方法可以用于获取和修改这些数据。</p><p>底层的实现是通过Java的反射机制来实现属性的访问和操作。Java Bean使用反射来动态地获取和设置属性的值，而无需直接访问属性本身。这使得Java Bean具有更大的灵活性和可扩展性。</p><p>Java Bean的使用场景非常广泛。它可以用于表示任何具有属性和行为的实体，如用户、产品、订单等。Java Bean可以作为数据传输对象（DTO）在不同的层之间传递数据，也可以作为持久化对象（POJO）存储在数据库中。此外，Java Bean还可以用于实现事件处理、数据绑定和其他各种功能。</p><p>总结起来，Java Bean可以比喻为一个装满各种食材的保温饭盒。它封装了数据和行为，使其更易于管理和操作。底层使用Java的反射机制来实现属性的访问和操作。Java Bean的使用场景非常广泛，可以用于表示实体、传递数据、存储数据等各种用途。</p><h3 id="java-的反射" tabindex="-1">java 的反射 <a class="header-anchor" href="#java-的反射" aria-hidden="true">#</a></h3><p>java的反射机制是指在运行时动态地获取和操作类的信息，包括类的属性、方法和构造函数等。它允许程序在运行时检查和修改类的结构，而无需在编译时知道类的具体信息。</p><p>可以将Java的反射机制比喻为一个万能钥匙，它可以打开任何门并查看和修改门内的内容。类比到Java中，反射机制可以让程序员在运行时“打开”类，并获取和修改类的属性和方法等信息。</p><p>为什么需要反射机制呢？因为有些情况下，我们无法在编译时确定类的具体信息，或者需要在运行时动态地创建对象、调用方法等。反射机制提供了一种灵活的方式来处理这些情况，使得程序能够根据运行时的需求来动态地操作类。 Java 反射机制使得程序可以像操作数据一样操作类和对象，可以实现许多高级功能，例如通过反射来加载、实例化和调用不同的类、实现基于配置的应用、生成动态代理、在运行时检查注解等</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">import java.lang.reflect.Field;</span></span>
<span class="line"><span style="color:#A6ACCD;">import java.lang.reflect.Method;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">public class ReflectionExample {</span></span>
<span class="line"><span style="color:#A6ACCD;">    public static void main(String[] args) throws Exception {</span></span>
<span class="line"><span style="color:#A6ACCD;">        // 获取类的信息</span></span>
<span class="line"><span style="color:#A6ACCD;">        Class&lt;?&gt; clazz = MyClass.class;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 获取类的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">        Field[] fields = clazz.getDeclaredFields();</span></span>
<span class="line"><span style="color:#A6ACCD;">        for (Field field : fields) {</span></span>
<span class="line"><span style="color:#A6ACCD;">            System.out.println(&quot;Field: &quot; + field.getName());</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">        // 调用类的方法</span></span>
<span class="line"><span style="color:#A6ACCD;">        Method method = clazz.getDeclaredMethod(&quot;myMethod&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">        method.invoke(clazz.newInstance());</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">class MyClass {</span></span>
<span class="line"><span style="color:#A6ACCD;">    private String myField;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">    public void myMethod() {</span></span>
<span class="line"><span style="color:#A6ACCD;">        System.out.println(&quot;Hello, Reflection!&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在这个示例中，我们使用反射来获取MyClass类的信息。首先，我们通过Class.forName()方法或直接使用类名获取MyClass的Class对象。然后，我们使用getDeclaredFields()方法获取类的所有属性，并使用getDeclaredMethod()方法获取类的方法。最后，我们使用invoke()方法调用类的方法。</p><p>通过手动创建反射，我们可以在运行时动态地获取类的信息并操作它。这在某些情况下非常有用，例如在框架和库中，它们需要根据用户的配置和需求来动态地创建对象和调用方法。</p><p>总结起来，Java的反射机制可以比喻为一个万能钥匙，它可以在运行时动态地获取和操作类的信息。反射机制的存在是为了处理在编译时无法确定类的具体信息或需要在运行时动态地创建对象和调用方法的情况。我们可以手动创建反射来获取类的信息并操作它，通过使用Class对象、Field对象和Method对象等来实现</p><h3 id="spring-boot-的版本" tabindex="-1">Spring boot 的版本 <a class="header-anchor" href="#spring-boot-的版本" aria-hidden="true">#</a></h3><p>Spring Boot的版本选择一般是这样的，如下图：</p><p>那版本号后面的英文代表什么含义呢？</p><p>具体含义，如下文所示：</p><p>SNAPSHOT：快照版，表示开发版本，随时可能修改； M1（Mn）：M是milestone的缩写，也就是里程碑版本； RC1（RCn）：RC是release candidates的缩写，也就是发布预览版； Release：正式版，也可能没有任何后缀也表示正式版</p><p>mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true</p><h3 id="spring-boot-中的" tabindex="-1">spring boot 中的@ <a class="header-anchor" href="#spring-boot-中的" aria-hidden="true">#</a></h3><p>在Spring Boot中，以@开头的内容通常是注解（Annotation）。注解是一种用于提供元数据（metadata）的特殊标记，它可以应用于类、方法、字段等程序元素上，用于提供额外的信息或指示特定的行为。</p><p>类比来解释注解的作用，可以将其类比为贴在物品上的标签。这些标签可以告诉程序一些额外的信息，或者指示程序执行特定的操作。</p><p>例如，@RestController是一个常见的注解，用于标记一个类，表示这个类是一个用于处理HTTP请求的控制器。类似于将一个标签贴在一个类上，告诉Spring框架这个类是一个控制器，用于处理请求和返回响应。</p><p>另一个例子是@Autowired注解，它可以应用于字段、构造函数或方法上。这个注解告诉Spring框架自动装配（自动注入）相关的依赖项，即自动将需要的对象注入到标记了@Autowired的位置。</p><p>总之，注解是一种在Spring Boot中用于提供额外信息和指示特定行为的特殊标记。它们可以帮助框架理解和处理代码，简化开发过程，并提供更好的可读性和可维护性</p>`,40),i=[p];function t(o,r,c,d,C,g){return s(),n("div",null,i)}const v=a(l,[["render",t]]);export{A as __pageData,v as default};
