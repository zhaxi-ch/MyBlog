import{_ as l,c as i,o as n,d as e,a}from"./app.1cd524f6.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"基础规定和语法","slug":"基础规定和语法","link":"#基础规定和语法","children":[{"level":3,"title":"Java 常量","slug":"java-常量","link":"#java-常量","children":[]},{"level":3,"title":"JSR JCP 是啥","slug":"jsr-jcp-是啥","link":"#jsr-jcp-是啥","children":[]},{"level":3,"title":"布尔运算","slug":"布尔运算","link":"#布尔运算","children":[]},{"level":3,"title":"字符和字符串","slug":"字符和字符串","link":"#字符和字符串","children":[]},{"level":3,"title":"字符串连接","slug":"字符串连接","link":"#字符串连接","children":[]},{"level":3,"title":"从Java 13开始，字符串可以用\\"\\"\\"...\\"\\"\\"表示多行字符串（Text Blocks）了","slug":"从java-13开始-字符串可以用-表示多行字符串-text-blocks-了","link":"#从java-13开始-字符串可以用-表示多行字符串-text-blocks-了","children":[]},{"level":3,"title":"数组变量","slug":"数组变量","link":"#数组变量","children":[]},{"level":3,"title":"Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：","slug":"java的格式化功能提供了多种占位符-可以把各种数据类型-格式化-成指定的字符串","link":"#java的格式化功能提供了多种占位符-可以把各种数据类型-格式化-成指定的字符串","children":[]},{"level":3,"title":"要判断引用类型的变量内容是否相等，必须使用equals()方法","slug":"要判断引用类型的变量内容是否相等-必须使用equals-方法","link":"#要判断引用类型的变量内容是否相等-必须使用equals-方法","children":[]},{"level":3,"title":"while循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。","slug":"while循环语句就是让计算机根据条件做循环计算-在条件满足时继续循环-条件不满足时退出循环。","link":"#while循环语句就是让计算机根据条件做循环计算-在条件满足时继续循环-条件不满足时退出循环。","children":[]},{"level":3,"title":"在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是","slug":"在java中-while循环是先判断循环条件-再执行循环。而另一种do-while循环则是先执行循环-再判断条件-条件满足时继续循环-条件不满足时退出。它的用法是","link":"#在java中-while循环是先判断循环条件-再执行循环。而另一种do-while循环则是先执行循环-再判断条件-条件满足时继续循环-条件不满足时退出。它的用法是","children":[]},{"level":3,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]},{"level":3,"title":"命令行參數","slug":"命令行參數","link":"#命令行參數","children":[]},{"level":3,"title":"JAVA 字符的方法","slug":"java-字符的方法","link":"#java-字符的方法","children":[]},{"level":3,"title":"为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：","slug":"为了让编译器能自动检查某个值在枚举的集合内-并且-不同用途的枚举需要不同的类型来标记-不能混用-我们可以使用enum来定义枚举类","link":"#为了让编译器能自动检查某个值在枚举的集合内-并且-不同用途的枚举需要不同的类型来标记-不能混用-我们可以使用enum来定义枚举类","children":[]},{"level":3,"title":"Math 类","slug":"math-类","link":"#math-类","children":[]},{"level":3,"title":"Lambad  (兰布达) 希娜字母的11","slug":"lambad-兰布达-希娜字母的11","link":"#lambad-兰布达-希娜字母的11","children":[]},{"level":3,"title":"多态","slug":"多态","link":"#多态","children":[]}]},{"level":2,"title":"继承 inherit","slug":"继承-inherit","link":"#继承-inherit","children":[{"level":3,"title":"重写 Override","slug":"重写-override","link":"#重写-override","children":[]},{"level":3,"title":"重载(Overload)","slug":"重载-overload","link":"#重载-overload","children":[]},{"level":3,"title":"抽象类","slug":"抽象类","link":"#抽象类","children":[]},{"level":3,"title":"封装  Encapsulation","slug":"封装-encapsulation","link":"#封装-encapsulation","children":[]}]},{"level":2,"title":"接口  interface","slug":"接口-interface","link":"#接口-interface","children":[]},{"level":2,"title":"枚举 enum","slug":"枚举-enum","link":"#枚举-enum","children":[{"level":3,"title":"包 package","slug":"包-package","link":"#包-package","children":[]},{"level":3,"title":"构造函数，","slug":"构造函数","link":"#构造函数","children":[]},{"level":3,"title":"java 的数据结构","slug":"java-的数据结构","link":"#java-的数据结构","children":[]}]},{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[{"level":3,"title":"socket 通信","slug":"socket-通信","link":"#socket-通信","children":[]}]},{"level":2,"title":"","slug":"","link":"#","children":[{"level":3,"title":"调用另一个文件的类","slug":"调用另一个文件的类","link":"#调用另一个文件的类","children":[]},{"level":3,"title":"set是一种常见的命名约定，用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值","slug":"set是一种常见的命名约定-用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值","link":"#set是一种常见的命名约定-用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值","children":[]}]}],"relativePath":"devm/java/jichu/index.md"}'),t={name:"devm/java/jichu/index.md"},s=e(`<h2 id="基础规定和语法" tabindex="-1">基础规定和语法 <a class="header-anchor" href="#基础规定和语法" aria-hidden="true">#</a></h2><h3 id="java-常量" tabindex="-1">Java 常量 <a class="header-anchor" href="#java-常量" aria-hidden="true">#</a></h3><p>常量在程序运行时是不能被修改的。 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">double</span><span style="color:#A6ACCD;"> PI </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3.1415927</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h3 id="jsr-jcp-是啥" tabindex="-1">JSR JCP 是啥 <a class="header-anchor" href="#jsr-jcp-是啥" aria-hidden="true">#</a></h3><ul><li>JSR规范：<code>Java Specification Request</code></li><li>JCP组织：<code>Java Community Process</code> 为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</li></ul><h3 id="布尔运算" tabindex="-1">布尔运算 <a class="header-anchor" href="#布尔运算" aria-hidden="true">#</a></h3><p>布尔运算的一个重要特点是短路运算</p><p>布尔运算是一种关系运算，包括以下几类：</p><ul><li>比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=</li><li>与运算 &amp;&amp;</li><li>或运算 ||</li><li>非运算 ! <code>关系运算符的优先级从高到低依次是：</code></li></ul><p>!</p><blockquote><p>，&gt;=，&lt;，&lt;= ==，!= &amp;&amp; ||</p></blockquote><h3 id="字符和字符串" tabindex="-1">字符和字符串 <a class="header-anchor" href="#字符和字符串" aria-hidden="true">#</a></h3><p>在Java中，字符和字符串是两个不同的类型。</p><p>字符类型 字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符：</p><h3 id="字符串连接" tabindex="-1">字符串连接 <a class="header-anchor" href="#字符串连接" aria-hidden="true">#</a></h3><p>Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：</p><p><code>如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接</code></p><h3 id="从java-13开始-字符串可以用-表示多行字符串-text-blocks-了" tabindex="-1">从Java 13开始，字符串可以用&quot;&quot;&quot;...&quot;&quot;&quot;表示多行字符串（Text Blocks）了 <a class="header-anchor" href="#从java-13开始-字符串可以用-表示多行字符串-text-blocks-了" aria-hidden="true">#</a></h3><h3 id="数组变量" tabindex="-1">数组变量 <a class="header-anchor" href="#数组变量" aria-hidden="true">#</a></h3><p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。</p><p>Java的数组有几个特点：</p><p>数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。</p><p>可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;</p><h3 id="java的格式化功能提供了多种占位符-可以把各种数据类型-格式化-成指定的字符串" tabindex="-1">Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串： <a class="header-anchor" href="#java的格式化功能提供了多种占位符-可以把各种数据类型-格式化-成指定的字符串" aria-hidden="true">#</a></h3><p>占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身</p><h3 id="要判断引用类型的变量内容是否相等-必须使用equals-方法" tabindex="-1">要判断引用类型的变量内容是否相等，必须使用equals()方法 <a class="header-anchor" href="#要判断引用类型的变量内容是否相等-必须使用equals-方法" aria-hidden="true">#</a></h3><p>对于多个==判断的情况，使用switch结构更加清晰。</p><h3 id="while循环语句就是让计算机根据条件做循环计算-在条件满足时继续循环-条件不满足时退出循环。" tabindex="-1">while循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。 <a class="header-anchor" href="#while循环语句就是让计算机根据条件做循环计算-在条件满足时继续循环-条件不满足时退出循环。" aria-hidden="true">#</a></h3><h3 id="在java中-while循环是先判断循环条件-再执行循环。而另一种do-while循环则是先执行循环-再判断条件-条件满足时继续循环-条件不满足时退出。它的用法是" tabindex="-1">在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是 <a class="header-anchor" href="#在java中-while循环是先判断循环条件-再执行循环。而另一种do-while循环则是先执行循环-再判断条件-条件满足时继续循环-条件不满足时退出。它的用法是" aria-hidden="true">#</a></h3><h3 id="冒泡排序" tabindex="-1">冒泡排序 <a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a></h3><h3 id="命令行參數" tabindex="-1">命令行參數 <a class="header-anchor" href="#命令行參數" aria-hidden="true">#</a></h3><p>Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。</p><h3 id="java-字符的方法" tabindex="-1">JAVA 字符的方法 <a class="header-anchor" href="#java-字符的方法" aria-hidden="true">#</a></h3><h4 id="用stringjoiner的结果少了前面的-hello-和结尾的-遇到这种情况-需要给stringjoiner指定-开头-和-结尾-这个内置方法-可以去头尾" tabindex="-1">用StringJoiner的结果少了前面的&quot;Hello &quot;和结尾的&quot;!&quot;！遇到这种情况，需要给StringJoiner指定“开头”和“结尾” （这个内置方法，可以去头尾） <a class="header-anchor" href="#用stringjoiner的结果少了前面的-hello-和结尾的-遇到这种情况-需要给stringjoiner指定-开头-和-结尾-这个内置方法-可以去头尾" aria-hidden="true">#</a></h4><h3 id="为了让编译器能自动检查某个值在枚举的集合内-并且-不同用途的枚举需要不同的类型来标记-不能混用-我们可以使用enum来定义枚举类" tabindex="-1">为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： <a class="header-anchor" href="#为了让编译器能自动检查某个值在枚举的集合内-并且-不同用途的枚举需要不同的类型来标记-不能混用-我们可以使用enum来定义枚举类" aria-hidden="true">#</a></h3><h3 id="math-类" tabindex="-1">Math 类 <a class="header-anchor" href="#math-类" aria-hidden="true">#</a></h3><p>顾名思义，Math类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><hr><h3 id="lambad-兰布达-希娜字母的11" tabindex="-1">Lambad (兰布达) 希娜字母的11 <a class="header-anchor" href="#lambad-兰布达-希娜字母的11" aria-hidden="true">#</a></h3><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑 使用 Lambda 表达式需要注意以下两点：</p><pre><code>Lambda 表达式主要用来定义行内执行的方法类型接口（例如，一个简单方法接口）。在上面例子中，我们使用各种类型的 Lambda 表达式来定义 MathOperation 接口的方法，然后我们定义了 operation 的执行。

Lambda 表达式免去了使用匿名方法的麻烦，并且给予 Java 简单但是强大的函数化的编程能力
</code></pre><h3 id="多态" tabindex="-1">多态 <a class="header-anchor" href="#多态" aria-hidden="true">#</a></h3><p>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</p><p>多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p = new Child(); 虚函数 虚函数的存在是为了多态 当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p><p>要想调用父类中被重写的方法，则必须使用关键字 super</p><h2 id="继承-inherit" tabindex="-1">继承 inherit <a class="header-anchor" href="#继承-inherit" aria-hidden="true">#</a></h2><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends 继承类， implements 实现接口</p><h3 id="重写-override" tabindex="-1">重写 Override <a class="header-anchor" href="#重写-override" aria-hidden="true">#</a></h3><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 在面向对象原则里，重写意味着可以重写任何现有方法</p><blockquote><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。<br> 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常</p></blockquote><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p><h3 id="重载-overload" tabindex="-1">重载(Overload) <a class="header-anchor" href="#重载-overload" aria-hidden="true">#</a></h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器的重载</p><ul><li>方法重载(Overloading)：如果有两个方法的方法名相同，但参数不一致，哪么可以说一个方法是另一个方法的重载。</li><li>方法覆盖（Overriding）：如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。</li></ul><h3 id="抽象类" tabindex="-1">抽象类 <a class="header-anchor" href="#抽象类" aria-hidden="true">#</a></h3><p>在面向对象中，所有的对象都是通过类来描述的，但是反过来，并不是所有的类都可以用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就叫做抽象类 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用！一个类可以实现多个接口 引入抽象方法和抽象类，是Java提供的一种语法工具，对于一些类和方法，引导使用者正确使用它们，减少被误用。</p><h3 id="封装-encapsulation" tabindex="-1">封装 Encapsulation <a class="header-anchor" href="#封装-encapsulation" aria-hidden="true">#</a></h3><p>封装是指将一种抽象性函式接口的实现细节部分包装，隐藏起来的方法</p><h2 id="接口-interface" tabindex="-1">接口 interface <a class="header-anchor" href="#接口-interface" aria-hidden="true">#</a></h2><p>接口的特性：</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，可以不使用abstract 关键字</li><li>接口中 的每一个方法都是隐式的抽象的，声明时不需要关键字abstract</li><li>接口中的方法都是公有的</li></ul><h2 id="枚举-enum" tabindex="-1">枚举 enum <a class="header-anchor" href="#枚举-enum" aria-hidden="true">#</a></h2><p>枚举是一个特殊的类，一般表示一组常量，比如四季，12个月，星期几</p><p>枚举跟普通类一样可以使用自己的变量，方法和构造函数， 构造函数只能使用private 访问修饰符，所以外部无法访问</p><h3 id="包-package" tabindex="-1">包 package <a class="header-anchor" href="#包-package" aria-hidden="true">#</a></h3><p>为了区别类名的命名空间</p><ul><li>把功能相似的或者相关的类或接口组织在同一个包中，方便类的查找和使用</li><li>同一个文件夹，包采用树型目录存储方式</li><li>包也限定了访问权限，拥有包权限的类才能访问某个包中的类</li></ul><p>创建包 通常使用小写字母来命名，避免与类，接口名字的冲突</p><h3 id="构造函数" tabindex="-1">构造函数， <a class="header-anchor" href="#构造函数" aria-hidden="true">#</a></h3><p>是一种特殊的函数，与函数名称相同，无返回值 一般使用初始化成员的属性和方法，即Nes 对象后，就调用了对象的属性和方法</p><p>具有参数的构造函数 称为参数化构造函数</p><h3 id="java-的数据结构" tabindex="-1">java 的数据结构 <a class="header-anchor" href="#java-的数据结构" aria-hidden="true">#</a></h3><ul><li><p>枚举 Emumeration</p></li><li><p>位集合 Bitsit</p></li><li><p>向量 Vector Vector.sort 方法对向量进行排序</p></li><li><p>栈 stack</p></li><li><p>字典 Dictionary</p><p>字典就是有个抽象类，它定义了键映射到值的数据结构</p></li><li><p>哈希表 Hashtable</p></li><li><p>属性 Properties</p></li></ul><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-hidden="true">#</a></h2><h4 id="linkedlist-线性表" tabindex="-1">Linkedlist 线性表 <a class="header-anchor" href="#linkedlist-线性表" aria-hidden="true">#</a></h4><p>类似于 Arraylist 是一种重圆的数据容器</p><p>以下情况使用Linkedlist</p><ul><li>需要通过循环迭代来访问列表中的某些元素</li><li>需要频繁的在列表开头，中间，结尾处进行刷出元素操作等</li></ul><h4 id="hashset" tabindex="-1">HashSet <a class="header-anchor" href="#hashset" aria-hidden="true">#</a></h4><p>HashSet 基于HashMap 来实现的，是一个不允许有重复元素的集合</p><h4 id="iterator-迭代器" tabindex="-1">iterator 迭代器 <a class="header-anchor" href="#iterator-迭代器" aria-hidden="true">#</a></h4><p>iterator 不是一个集合，它是一种用于访问集合方法，可用于迭代Arraylist 和 HashSet</p><h4 id="泛型-generics-泛型提供了编译时类型安全检测机制-该机制允许在编译时检测到非法的类型" tabindex="-1">泛型 generics 泛型提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型 <a class="header-anchor" href="#泛型-generics-泛型提供了编译时类型安全检测机制-该机制允许在编译时检测到非法的类型" aria-hidden="true">#</a></h4><h3 id="socket-通信" tabindex="-1">socket 通信 <a class="header-anchor" href="#socket-通信" aria-hidden="true">#</a></h3><p>JDBC 内部底层其实是socket 通信</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><h3 id="调用另一个文件的类" tabindex="-1">调用另一个文件的类 <a class="header-anchor" href="#调用另一个文件的类" aria-hidden="true">#</a></h3><p>在java里怎么在一个java程序里调用运行另一个java类? 先把2个文件放在同一个包下面，这样就可以访问另一个java程序了。</p><p>java怎么调用另一个类的方法 java类有两种方法一种是类方法就是用static修饰的， 一种是实例方法，就是没有static修饰的方法。类方法可以同时类名.方法名的方式调用。</p>`,95),r=a("blockquote",{"css-module":"."},[a("p",null,"用静态公有方法的语法是：类名.方法名(参数...); 所以，比如另一个类叫OtherClass，它的静态公有方法是 public static int MethodA()")],-1),h=e(`<blockquote><p>那么在你自己的类里调用的方式就是：int result = OtherClass.MethodA(); 另外，调用非静态公有方法（也叫成员方法），比如方法叫 public int MethodB() {...} 就必须先创建这个类的对象再调用其方法， 例如：int result2 = new OtherClass().MethodB();</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> 在Java中，静态方法是属于类而不是对象的方法。它们可以直接通过类名调用，而无需创建类的实例。静态方法有以下几个常见的用途和优势：</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">1. 工具方法：静态方法通常用于实现一些通用的功能，例如数学计算、字符串处理等。由于它们不依赖于特定的对象状态，因此可以直接通过类名调用，方便使用。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">2. 简化代码：静态方法可以在不创建对象的情况下执行操作，这样可以避免创建不必要的对象。这对于一些简单的操作或者不需要访问对象状态的方法来说，可以提高代码的简洁性和执行效率。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">3. 共享数据：静态方法可以访问和修改静态变量，这些变量在类的所有实例之间是共享的。这使得静态方法可以用于处理和操作共享数据，而不需要每个实例都保存一份副本。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">4. 工厂方法：静态方法可以用于创建对象实例，这种模式被称为工厂方法模式。通过在静态方法中封装对象的创建逻辑，可以提供更灵活的对象创建方式，同时隐藏具体的实现细节。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">需要注意的是，静态方法不能直接访问非静态成员（例如实例变量和实例方法），因为它们没有隐式的this引用。此外，静态方法不能被子类重写，因为它们属于类而不是对象。</span></span>
<span class="line"><span style="color:#A6ACCD;">总而言之，静态方法在Java中具有一些特殊的用途和优势，可以提供更简洁、高效和灵活的代码实现方式。然而，过度使用静态方法可能导致代码难以测试和维护，因此应该根据具体的需求和设计原则来合理使用</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在Java中，与类名相同的方法被称为构造方法（Constructor）。构造方法是一种特殊的方法，用于创建和初始化对象。构造方法的名称必须与类名完全相同，并且没有返回类型（包括void）。构造方法在创建对象时自动调用，并且可以用于执行必要的初始化操作</p><h3 id="set是一种常见的命名约定-用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值" tabindex="-1">set是一种常见的命名约定，用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值 <a class="header-anchor" href="#set是一种常见的命名约定-用于设置对象的属性或配置。它通常用于通过方法调用来设置对象的属性值" aria-hidden="true">#</a></h3><p>使用set方法的好处是它提供了一种统一的方式来设置对象的属性或配置，使代码更易读和维护。此外，set方法还可以提供一些额外的逻辑，例如验证输入值的有效性或触发其他操作。</p>`,5),d=[s,r,h];function c(p,o,u,v,b,k){return n(),i("div",null,d)}const m=l(t,[["render",c]]);export{f as __pageData,m as default};
