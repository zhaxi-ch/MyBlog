import{_ as p,c as a,o as t,d as e}from"./app.ef8ea805.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"源文件声明规则","slug":"源文件声明规则","link":"#源文件声明规则","children":[]},{"level":2,"title":"Java 包","slug":"java-包","link":"#java-包","children":[]},{"level":2,"title":"import 语句","slug":"import-语句","link":"#import-语句","children":[]}],"relativePath":"devm/java/index.md"}'),i={name:"devm/java/index.md"},s=e(`<h2 id="源文件声明规则" tabindex="-1">源文件声明规则 <a class="header-anchor" href="#源文件声明规则" aria-hidden="true">#</a></h2><p><code>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</code></p><p>一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p><h2 id="java-包" tabindex="-1">Java 包 <a class="header-anchor" href="#java-包" aria-hidden="true">#</a></h2><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类</p><h2 id="import-语句" tabindex="-1">import 语句 <a class="header-anchor" href="#import-语句" aria-hidden="true">#</a></h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p><p>例如，下面的命令行将会命令编译器载入 java_installation/java/io 路径下的所有类</p><hr><p>———————————————————————————————————————————</p><p>Java基础知识总结（超级经典）</p><p>写代码：</p><p>1，明确需求。我要做什么？</p><p>2，分析思路。我要怎么做？1,2,3。</p><p>3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。</p><p>4，代码实现。用具体的java语言代码把思路体现出来。</p><p>学习新技术的四点：</p><p>1，该技术是什么？</p><p>2，该技术有什么特点(使用注意)：</p><p>3，该技术怎么使用。demo</p><p>4，该技术什么时候用？test。</p><p>————————————————————————————————</p><p>一：java概述：</p><p>1991 年Sun公司的James Gosling等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器；</p><p>1994年将Oak语言更名为Java；</p><p>Java的三种技术架构:</p><p>JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；</p><p>JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；</p><p>JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；</p><p>1，JDK：Java Development Kit：java的开发和运行环境，java的开发工具和jre。</p><p>2，JRE：Java Runtime Environment：java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。</p><p>3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。</p><p>环境变量的配置：</p><p>①：永久配置方式：JAVA_HOME=%安装路径%\\Java\\jdk</p><p>path=%JAVA_HOME%\\bin</p><p>②：临时配置方式：set path=%path%;C:\\Program Files\\Java\\jdk\\bin</p><p>特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。</p><p>classpath的配置:</p><p>①：永久配置方式：classpath=.;c:;e:\\</p><p>②：临时配置方式：set classpath=.;c:;e:\\</p><p>注意：在定义classpath环境变量时，需要注意的情况</p><p>如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；</p><p>如果指定了classpath，那么会在指定的目录下查找要运行的类文件。</p><p>还会在当前目录找吗？两种情况：</p><p>①：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。</p><p>②：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。</p><p>一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。</p><p>4，javac命令和java命令做什么事情呢？</p><p>要知道java是分两部分的：一个是编译，一个是运行。</p><p></p><p>javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。</p><p>java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.</p><p>——————————————————————————————————————————————————————</p><p>二：java语法基础：</p><p>1，关键字：其实就是某种语言赋予了特殊含义的单词。</p><p>保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。</p><p>2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0—9、a—z、$、_ ；</p><p>注意：</p><p>①：数字不可以开头。</p><p>②：不可以使用关键字。</p><p>3，常量：是在程序中的不会变化的数据。</p><p>4，变量：其实就是内存中的一个存储空间，用于存储常量数据。</p><p>作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。</p><p>特点：变量空间可以重复使用。</p><p>什么时候定义变量？只要是数据不确定的时候，就定义变量。</p><p>变量空间的开辟需要什么要素呢？</p><p>①：这个空间要存储什么数据？数据类型。</p><p>②：这个空间叫什么名字啊？变量名称。</p><p>③：这个空间的第一次的数据是什么？ 变量的初始化值。</p><p>变量的作用域和生存期:</p><p>变量的作用域：</p><pre><code>　　　　作用域从变量定义的位置开始，到该变量所在的那对大括号结束；
</code></pre><p>生命周期：</p><pre><code>　　　　变量从定义的位置开始就在内存中活了；

　　　　变量到达它所在的作用域的时候就在内存中消失了；
</code></pre><p>数据类型：</p><p>①：基本数据类型：byte、short、int、long、float、double、char、boolean</p><p>②：引用数据类型: 数组、类、接口。</p><p>级别从低到高为：byte,char,short(这三个平级)——&gt;int——&gt;float——&gt;long——&gt;double</p><p>自动类型转换：从低级别到高级别，系统自动转的；</p><p>强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；</p><p>运算符号：</p><p>①、算术运算符。</p><p>+ — * / %</p><p>%:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。</p><p>+:连接符。</p><p>++,——</p><p>②、赋值运算符。</p><p>= += —= *= /= %=</p><p>③、比较运算符。</p><p>特点：该运算符的特点是：运算完的结果，要么是true，要么是false。</p><p>④、逻辑运算符。</p><p>&amp; | ^ ! &amp;&amp; ||</p><p>逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。</p><p>&amp;: 只有两边都为true结果是true。否则就是false。</p><p>|:只要两边都为false结果是false，否则就是true</p><p>^:异或：和或有点不一样。</p><p>两边结果一样，就为false。</p><p>两边结果不一样，就为true.</p><p>&amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。</p><p>&amp;&amp;:短路与，如果左边为false，那么右边不参数与运算。</p><p>| 和|| 区别： |：两边都运算。</p><p>||：短路或，如果左边为true，那么右边不参与运算。</p><p>⑤、位运算符:用于操作二进制位的运算符。</p><p>&amp; | ^</p><p>&lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移)</p><p>练习：对两个变量的数据进行互换。不需要第三方变量。</p><p>int a = 3,b = 5;//——&gt;b = 3,a = 5;</p><p>a = a + b; a = 8;</p><p>b = a — b; b = 3;</p><p>a = a — b; a = 5;</p><p>a = a ^ b;//</p><p>b = a ^ b;//b = a ^ b ^ b = a</p><p>a = a ^ b;//a = a ^ b ^ a = b;</p><p>练习：高效的算出 2*8 = 2&lt;&lt;3;</p><p>5，语句。</p><p>If 　　 switch 　　do while 　　 while 　　 for</p><p>这些语句什么时候用？</p><p>1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。</p><p>但是建议使用switch，效率相对较高。</p><p>switch(变量){</p><p>case 值:要执行的语句;break;</p><p>…</p><p>default:要执行的语句;</p><p>}</p><p>工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了</p><p>就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；</p><p>细节：①：break是可以省略的，如果省略了就一直执行到遇到break为止；</p><p>②、switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；</p><p>③、default可以写在switch结构中的任意位置；如果将default语句放在了第一行，</p><p>则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。</p><p>2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。</p><p>3）、当某些语句需要执行很多次时，就用循环结构。</p><p>while和for可以进行互换。</p><p>区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。</p><p>break:作用于switch ，和循环语句，用于跳出，或者称为结束。</p><p>break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。</p><p>continue:只作用于循环结构，继续循环用的。</p><p>作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。</p><p>6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。</p><p>java中的函数的定义格式：</p><p>修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){</p><p>执行语句；</p><p>return 返回值；</p><p>}</p><p>当函数没有具体的返回值时，返回的返回值类型用void关键字表示。</p><p>如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。</p><p>return的作用：结束函数。结束功能。</p><p>如何定义一个函数？</p><p>函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：</p><p>①、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。</p><p>②、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。</p><p>函数的作用：</p><p>1）、用于定义功能。</p><p>2）、用于封装代码提高代码的复用性。</p><p>注意：函数中只能调用函数，不能定义函数。</p><p>主函数：</p><p>1）、保证该类的独立运行。</p><p>2）、因为它是程序的入口。</p><p>3）、因为它在被jvm调用。</p><p>函数定义名称是为什么呢？</p><p>答：1）、为了对该功能进行标示，方便于调用。</p><p>2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。</p><p>重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。</p><p>如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。</p><p>7，数 组：用于存储同一类型数据的一个容器。</p><p>好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。</p><p>如何在java中表现一个数组呢？两种表现形式。</p><p>1）、元素类型[] 变量名 = new 元素类型[元素的个数]；</p><p>2）、元素类型[] 变量名 = {元素1，元素2...}；</p><p>元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；</p><p>——————————————————————————————————————————————————————</p><p>//二分查找法。必须有前提：数组中的元素要有序。</p><p>public static int halfSeach_2(int[] arr,int key){</p><p>int min,max,mid;</p><p>min = 0;</p><p>max = arr.length—1;</p><p>mid = (max+min)&gt;&gt;1; //(max+min)/2;</p><p>while(arr[mid]!=key){</p><p>if(key&gt;arr[mid]){</p><p>min = mid + 1;</p><p>}</p><p>else if(key&lt;arr[mid])</p><p>max = mid — 1;</p><p>if(max&lt;min)</p><p>return —1;</p><p>mid = (max+min)&gt;&gt;1;</p><p>}</p><p>return mid;</p><p>}</p><p>——————————————————————————————————————————————————————</p><p>java分了5片内存。</p><p>1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。</p><p>栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；</p><p>只要数据运算完成所在的区域结束，该数据就会被释放。</p><p>堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。</p><p>1：每一个实体都有内存首地址值。</p><p>2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p><p>3：垃圾回收机制。</p><p>——————————————————————————————————————————————————————</p><p>三：面向对象：★★★★★</p><p>特点：1：将复杂的事情简单化。</p><p>2：面向对象将以前的过程中的执行者，变成了指挥者。</p><p>3：面向对象这种思想是符合现在人们思考习惯的一种思想。</p><p>过程和对象在我们的程序中是如何体现的呢？</p><p>过程其实就是函数；</p><p>对象是将函数等一些内容进行了封装。</p><p>匿名对象使用场景：</p><p>1：当对方法只进行一次调用的时候，可以使用匿名对象。</p><p>2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。</p><p>在类中定义其实都称之为成员。成员有两种：</p><p>1：成员变量：其实对应的就是事物的属性。</p><p>2：成员函数：其实对应的就是事物的行为。</p><p>所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。</p><p>private int age;//私有的访问权限最低，只有在本类中的访问有效。</p><p>注意：私有仅仅是封装的一种体现形式而已。</p><p>私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，</p><p>可以通过对外提供函数的形式对其进行访问。</p><p>好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。</p><p>总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。</p><p>这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。</p><p>类中怎么没有定义主函数呢？</p><p>注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。</p><p>主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。</p><p>成员变量和局部变量的区别：</p><p>1：成员变量直接定义在类中。</p><p>局部变量定义在方法中，参数上，语句中。</p><p>2：成员变量在这个类中有效。</p><p>局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。</p><p>3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。</p><p>局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。</p><p>构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。</p><p>特点：</p><p>1：该函数的名称和所在类的名称相同。</p><p>2：不需要定义返回值类型。</p><p>3：该函数没有具体的返回值。</p><p>记住：所有对象创建时，都需要初始化才可以使用。</p><p>注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，</p><p>为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。</p><p>一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，</p><p>一个类中如果出现多个构造函数。它们的存在是以重载体现的。</p><p>构造函数和一般函数有什么区别呢？</p><p>1：两个函数定义格式不同。</p><p>2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。</p><p>一般函数，是对象创建后，需要调用才执行，可以被调用多次。</p><p>什么时候使用构造函数呢？</p><p>分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。</p><p>构造代码块和构造函数有什么区别？</p><p>构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。</p><p>构造函数：是给与之对应的对象进行初始化。它具有针对性。</p><p>Person p = new Person();</p><p>创建一个对象都在内存中做了什么事情？</p><p>1：先将硬盘上指定位置的Person.class文件加载进内存。</p><p>2：执行main方法时，在栈内存中开辟了main方法的空间(压栈—进栈)，然后在main方法的栈区分配了一个变量p。</p><p>3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</p><p>4：在该实体空间中进行属性的空间分配，并进行了默认初始化。</p><p>5：对空间中的属性进行显示初始化。</p><p>6：进行实体的构造代码块初始化。</p><p>7：调用该实体对应的构造函数，进行构造函数初始化。（）</p><p>8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</p><p>——————————————————————————————————————————————————————</p><p>封 装（面向对象特征之一）：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p><p>好处：将变化隔离；便于使用；提高重用性；安全性。</p><p>封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。</p><p>this:代表对象。就是所在函数所属对象的引用。</p><p>this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。</p><p>开发时，什么时候使用this呢？</p><p>在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。</p><p>this 还可以用于构造函数间的调用。</p><p>调用格式：this(实际参数)；</p><p>this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)；</p><p>this对象后面跟上 () 调用的是本类中的对应参数的构造函数。</p><p>注意：用this调用构造函数，必须定义在构造函数的第一行。</p><p>因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。</p><p>static：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。</p><p>特点：</p><p>1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。</p><p>2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。</p><p>3，静态随着类的加载而加载。而且优先于对象存在。</p><p>弊端：</p><p>1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。</p><p>2，静态方法只能访问静态成员，不可以访问非静态成员。</p><p>因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。</p><p>3，静态方法中不能使用this，super关键字。</p><p>因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p><p>4，主函数是静态的。</p><p>什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？</p><p>成员分两种：</p><p>1，成员变量。（数据共享时静态化）</p><p>该成员变量的数据是否是所有对象都一样：</p><p>如果是，那么该变量需要被静态修饰，因为是共享的数据。</p><p>如果不是，那么就说这是对象的特有数据，要存储到对象中。</p><p>2，成员函数。（方法中没有调用特有数据时就定义成静态）</p><p>如果判断成员函数是否需要被静态修饰呢？</p><p>只要参考，该函数内是否访问了对象中的特有数据：</p><p>如果有访问特有数据，那方法不能被静态修饰。</p><p>如果没有访问过特有数据，那么这个方法需要被静态修饰。</p><p>成员变量和静态变量的区别：</p><p>1，成员变量所属于对象。所以也称为实例变量。</p><p>静态变量所属于类。所以也称为类变量。</p><p>2，成员变量存在于堆内存中。</p><p>静态变量存在于方法区中。</p><p>3，成员变量随着对象创建而存在。随着对象被回收而消失。</p><p>静态变量随着类的加载而存在。随着类的消失而消失。</p><p>4，成员变量只能被对象所调用 。</p><p>静态变量可以被对象调用，也可以被类名调用。</p><p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p><p>静态的注意：静态的生命周期很长。</p><p>静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。</p><p>作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。</p><p>Public：访问权限最大。</p><p>static：不需要对象，直接类名即可。</p><p>void：主函数没有返回值。</p><p>Main：主函数特定的名称。</p><p>(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。</p><p>jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。</p><p>静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 ———&gt; 构造代码块 ———&gt; 构造函数；</p><p>生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java</p><p>//格式</p><p>/**</p><p>*类描述</p><p>*@author 作者名</p><p>*@version 版本号</p><p>*/</p><p>/**</p><p>*方法描述</p><p>*@param 参数描述</p><p>*@return 返回值描述</p><p>*/</p><p>——————————————————————————————————————————————————————</p><p>设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><p>java中有23种设计模式：</p><p>单例设计模式：★★★★★</p><p>解决的问题：保证一个类在内存中的对象唯一性。</p><p>比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。</p><p>Runtime()方法就是单例设计模式进行设计的。</p><p>如何保证对象唯一性呢？</p><p>思想：</p><p>1，不让其他程序创建该类对象。</p><p>2，在本类中创建一个本类对象。</p><p>3，对外提供方法，让其他程序获取这个对象。</p><p>步骤：</p><p>1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；</p><p>2，就在类中创建一个本类的对象；</p><p>3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）</p><p>代码体现：</p><p>1，私有化构造函数；</p><p>2，创建私有并静态的本类对象；</p><p>3，定义公有并静态的方法，返回该对象。</p><p>——————————————————————————————————————————————————————</p><p>饿汉式</p><p>class Single{</p><p>private Single(){} //私有化构造函数。</p><p>private static Single s = new Single(); //创建私有并静态的本类对象。</p><p>public static Single getInstance(){ //定义公有并静态的方法，返回该对象。</p><p>return s;</p><p>}</p><p>}</p><p>——————————————————————————————————————————————————————</p><p>懒汉式:延迟加载方式。</p><p>class Single2{</p><p>private Single2(){}</p><p>private static Single2 s = null;</p><p>public static Single2 getInstance(){</p><p>if(s==null)</p><p>s = new Single2();</p><p>return s;</p><p>}</p><p>}</p><p>——————————————————————————————————————————————————————</p><p>继 承（面向对象特征之一）</p><p>好处：</p><p>1：提高了代码的复用性。</p><p>2：让类与类之间产生了关系，提供了另一个特征多态的前提。</p><p>父类的由来：其实是由多个类不断向上抽取共性内容而来的。</p><p>java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。</p><p>单继承：一个类只能有一个父类。</p><p>多继承：一个类可以有多个父类。</p><p>为什么不支持多继承呢？</p><p>因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。</p><p>但是java支持多重继承。A继承B B继承C C继承D。</p><p>多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。</p><p>所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。</p><p>简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。</p><p>子父类出现后，类中的成员都有了哪些特点：</p><p>1：成员变量。</p><p>当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。</p><p>如果想要调用父类中的属性值，需要使用一个关键字：super</p><p>This：代表是本类类型的对象引用。</p><p>Super：代表是子类所属的父类中的内存空间引用。</p><p>注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。</p><p>2：成员函数。</p><p>当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)</p><p>什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。</p><p>3：构造函数。</p><p>发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?</p><p>原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();</p><p>super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。</p><p>为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)</p><p>因为子类继承父类，会继承到父类中的数据，必须要看父类是如何对自己的数据进行初始化的。</p><p>所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p><p>注意：</p><p>子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</p><p>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</p><p>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p><p>问题：super()和this()是否可以同时出现的构造函数中。</p><p>两个语句只能有一个定义在第一行，所以只能出现其中一个。</p><p>super()或者this():为什么一定要定义在第一行？</p><p>因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。</p><p>继承的细节：</p><p>什么时候使用继承呢？</p><p>当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。</p><p>英文书中，所属关系：&quot; is a &quot;</p><p>注意：不要仅仅为了获取其他类中的已有成员进行继承。</p><p>所以判断所属关系，可以简单看，</p><p>如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。</p><p>细节二：</p><p>在方法覆盖时，注意两点：</p><p>1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。</p><p>2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)</p><p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p><p>这时如何解决问题呢？介绍一个关键字，final:最终。</p><p>final特点：</p><p>1：这个关键字是一个修饰符，可以修饰类，方法，变量。</p><p>2：被final修饰的类是一个最终类，不可以被继承。</p><p>3：被final修饰的方法是一个最终方法，不可以被覆盖。</p><p>4：被final修饰的变量是一个常量，只能赋值一次。</p><p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。</p><p>不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p><p>抽象类: abstract</p><p>抽象：不具体，看不明白。抽象类表象体现。</p><p>在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。</p><p>抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。</p><p>抽象类的特点：</p><p>1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。</p><p>2：抽象方法只定义方法声明，并不定义方法实现。</p><p>3：抽象类不可以被创建对象(实例化)。</p><p>4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</p><p>抽象类的细节：</p><p>1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。</p><p>2：抽象类中是否可以定义非抽象方法？</p><p>可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。</p><p>3：抽象关键字abstract和哪些不可以共存？final , private , static</p><p>4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</p><p>——————————————————————————————————————————————————————</p><p>模板方法设计模式：</p><p>解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><p>abstract class GetTime{</p><p>public final void getTime(){ 　　//此功能如果不需要复写，可加final限定</p><p>long start = System.currentTimeMillis();</p><p>code(); 　　//不确定的功能部分，提取出来，通过抽象方法实现</p><p>long end = System.currentTimeMillis();</p><p>System.out.println(&quot;毫秒是：&quot;+(end—start));</p><p>}</p><p>public abstract void code(); 　　//抽象不确定的功能，让子类复写实现</p><p>}</p><p>class SubDemo extends GetTime{</p><p>public void code(){ 　　//子类复写功能方法</p><p>for(int y=0; y&lt;1000; y++){</p><p>System.out.println(&quot;y&quot;);</p><p>}</p><p>}</p><p>}</p><p>——————————————————————————————————————————————————————</p><p>接 口：★★★★★</p><p>1：是用关键字interface定义的。</p><p>2：接口中包含的成员，最常见的有全局常量、抽象方法。</p><p>注意：接口中的成员都有固定的修饰符。</p><p>成员变量：public static final</p><p>成员方法：public abstract</p><p>interface Inter{</p><p>public static final int x = 3;</p><p>public abstract void show();</p><p>}</p><p>3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</p><p>4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。</p><p>继承用extends ；实现用implements ；</p><p>5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。</p><p>6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。</p><p>7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。</p><p>接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）</p><p>1：接口是对外提供的规则。</p><p>2：接口是功能的扩展。</p><p>3：接口的出现降低了耦合性。</p><p>抽象类与接口：</p><p>抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。</p><p>接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。</p><p>抽象类和接口的共性：都是不断向上抽取的结果。</p><p>抽象类和接口的区别：</p><p>1：抽象类只能被继承，而且只能单继承。</p><p>接口需要被实现，而且可以多实现。</p><p>2：抽象类中可以定义非抽象方法，子类可以直接继承使用。</p><p>接口中都有抽象方法，需要子类去实现。</p><p>3：抽象类使用的是 is a 关系。</p><p>接口使用的 like a 关系。</p><p>4：抽象类的成员修饰符可以自定义。</p><p>接口中的成员修饰符是固定的。全都是public的。</p><p>在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。</p><p>——————————————————————————————————————————————————————</p><p>多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。</p><p>体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();</p><p>多态的好处：提高了程序的扩展性。</p><p>多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)</p><p>多态的前提：</p><p>1：必须要有关系，比如继承、或者实现。</p><p>2：通常会有覆盖操作。</p><p>多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。</p><p>——————————————————————————————————————————————————————</p><p></p>`,508),r=[s];function n(l,c,o,m,v,d){return t(),a("div",null,r)}const b=p(i,[["render",n]]);export{u as __pageData,b as default};
